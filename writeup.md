# PWN

## 未分类

### *Test Your nc

ncat，启动！

# REVERSE

# WEB

# CRYPTO

## 未分类

## RSA

### easy_RSA

##### 题目描述

> [MTCTF 2021]
> 一次只能解决一个问题

##### 题目附件

> \easy_RSA
>     one_time_cipher.zip
>     padding_attack
>
> padding_attack:
>
> n:0x9371c61a2b760109781f229d43c6f05b58de65aa2a674ff92334cb5219132448d72c1293c145eb6f35e58791669f2d8d3b6ce506f4b3543beb947cf119f463a00bd33a33c4d566c4fd3f4c73c697fa5f3bf65976284b9cc96ec817241385d480003cdda9649fa0995b013e66f583c9a9710f7e18396fbf461cb31720f94a0f79L
>
> e:0x3
>
> encrypt(m):0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffbbd5a5e1a10f686c3f240e85d011f6c8b968d1d607b2e1d5a78ad6947b7d3ec8f33ad32489befab601fe745164e4ff4aed7630da89af7f902f6a1bf7266c9c95b29f2c69c33b93a709f282d43b10c61b1a1fe76f5fee970780d7512389fd1L
>
> encrypt(m+1):0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffc5c26b0c12bcff9f697f274f59f0e55a147768332fc1f1bac5bbc8f9bb508104f232bdd20091d26adc52e36feda4a156eae7dce4650f83fabc828fdcfb01d25efb98db8b94811ca855a6aa77caff991e7b986db844ff7a140218449aaa7e8L

##### 解题思路

注意到$e=3$很小，$m^e \space mod \space n,(m+1)^e \space mod \space n$二者前几位数字一样，推测$m^e<n$且$(m+1)^e$

测试：

```python
from gmpy2 import iroot
c=0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffbbd5a5e1a10f686c3f240e85d011f6c8b968d1d607b2e1d5a78ad6947b7d3ec8f33ad32489befab601fe745164e4ff4aed7630da89af7f902f6a1bf7266c9c95b29f2c69c33b93a709f282d43b10c61b1a1fe76f5fee970780d7512389fd1
print(iroot(c,3)[1])
#false
```

好的推测错误，继续推测$((m+1)^e-m^e) < 0$，则
$$
(m+1)^e-m^e = (m+1)^3-m^3 =3m^2+3m+1
$$
测试：

```python
c1=0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffbbd5a5e1a10f686c3f240e85d011f6c8b968d1d607b2e1d5a78ad6947b7d3ec8f33ad32489befab601fe745164e4ff4aed7630da89af7f902f6a1bf7266c9c95b29f2c69c33b93a709f282d43b10c61b1a1fe76f5fee970780d7512389fd1
c2=0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffc5c26b0c12bcff9f697f274f59f0e55a147768332fc1f1bac5bbc8f9bb508104f232bdd20091d26adc52e36feda4a156eae7dce4650f83fabc828fdcfb01d25efb98db8b94811ca855a6aa77caff991e7b986db844ff7a140218449aaa7e8
print((c2-c1-1)//3)
#0
```

测试通过，大概率说明$((m+1)^e-m^e) < 0$，下面解题：

```python
c1=0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffbbd5a5e1a10f686c3f240e85d011f6c8b968d1d607b2e1d5a78ad6947b7d3ec8f33ad32489befab601fe745164e4ff4aed7630da89af7f902f6a1bf7266c9c95b29f2c69c33b93a709f282d43b10c61b1a1fe76f5fee970780d7512389fd1
c2=0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffc5c26b0c12bcff9f697f274f59f0e55a147768332fc1f1bac5bbc8f9bb508104f232bdd20091d26adc52e36feda4a156eae7dce4650f83fabc828fdcfb01d25efb98db8b94811ca855a6aa77caff991e7b986db844ff7a140218449aaa7e8
from sympy import *
x,p = symbols('x p')
p=c2-c1
result = solve('(x+1)**3-x**3-0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffc5c26b0c12bcff9f697f274f59f0e55a147768332fc1f1bac5bbc8f9bb508104f232bdd20091d26adc52e36feda4a156eae7dce4650f83fabc828fdcfb01d25efb98db8b94811ca855a6aa77caff991e7b986db844ff7a140218449aaa7e8+0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffbbd5a5e1a10f686c3f240e85d011f6c8b968d1d607b2e1d5a78ad6947b7d3ec8f33ad32489befab601fe745164e4ff4aed7630da89af7f902f6a1bf7266c9c95b29f2c69c33b93a709f282d43b10c61b1a1fe76f5fee970780d7512389fd1')
from Crypto.Util.number import long_to_bytes
print(long_to_bytes(max(result)))
#b'the key is :everything_is_easy_in_this_question'
```

得到压缩包密码everything_is_easy_in_this_question

得到唯一文件one_time_cipher

>280316470206017f5f163a3460100b111b2c254e103715600f13,
>091b0f471d05153811122c70340c0111053a394e0b39500f0a18,
>4638080a1e49243e55531a3e23161d411a362e4044111f374409,
>0e0d15470206017f59122935601405421d3a244e10371560140f,
>031a08080e1a540d62327f242517101d4e2b2807177f13280511,
>0a090f001e491d2c111d3024601405431a36231b083e022c1d,
>16000406080c543854077f24280144451c2a254e093a0333051a,
>02050701120a01334553393f32441d5e1b716027107f19334417,
>131f15470800192f5d167f352e0716481e2b29010a7139600c12,
>1609411e141c543c501d7f232f0812544e2b2807177f00320b1f,
>0a090c470a1c1d3c5a1f2670210a0011093a344e103715600712,
>141e04040f49153142043a22601711520d3a331d0826

##### 一次一密

根据[Many-Time-Pad 攻击](https://www.ruanx.net/many-time-pad/)提供脚本：

```python
import Crypto.Util.strxor as xo
import libnum, codecs, numpy as np

def isChr(x):
    if ord('a') <= x and x <= ord('z'): return True
    if ord('A') <= x and x <= ord('Z'): return True
    return False

def infer(index, pos):
    if msg[index, pos] != 0:
        return
    msg[index, pos] = ord(' ')
    for x in range(len(c)):
        if x != index:
            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(' ')

dat = []

def getSpace():
    for index, x in enumerate(c):
        res = [xo.strxor(x, y) for y in c if x!=y]
        f = lambda pos: len(list(filter(isChr, [s[pos] for s in res])))
        cnt = [f(pos) for pos in range(len(x))]
        for pos in range(len(x)):
            dat.append((f(pos), index, pos))

c = [codecs.decode(x.strip().encode(), 'hex') for x in open('one_time_cipher', 'r').readlines()]

msg = np.zeros([len(c), len(c[0])], dtype=int)

getSpace()

dat = sorted(dat)[::-1]
for w, index, pos in dat:
    infer(index, pos)

print('\n'.join([''.join([chr(c) for c in x]) for x in msg]))

print()
print()


def know(index, pos, ch):
    msg[index, pos] = ord(ch)
    for x in range(len(c)):
        if x != index:
            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(ch)

#know(10, 21, 'y')
#know(8, 14, 'n')

#print('\n'.join([''.join([chr(c) for c in x]) for x in msg]))
```

对两个较短数据前补零尝试，得到

>N#w 6ou needPo u}eithe k
>o;n )lag as VLe kkyiof On
> im* Pad EnAVyptgng Now
>h-t 6ou haveTasskdithe p
>e:io:s RSA tGWt, zh s cha
>f*hh4w=BbB`F p4-KvWNBH
>
> ea<e get tJA tr{eimessa
>d%ff&cult foPyou  t is 
>u?t <imple eLGrypzi&n.I h
>p) y u can sMHve zh s pro
>l)m >uickly CJd gktithe c
>f ag wp[>:Ja D^FQuieC]l

感觉不太合理，试试后补零

>Nbw bou neYd tZ u}eithe k3
>ozn }lag aO thP kkyiof On8
> Yim~ Pad yncrLptgng Now )
>hlt bou haJe pTsskdithe p/
>e{ions RSAtesA, zh s cha1
>lhng~ is nSt pTrtgc<larly
>paeahe getthetr{eimessa:
>ddffrcult Zor Lou  t is 7
>u~t himpleencGypzi&n.I h2
>ph ytu cansolCe zh s pro?
>lhm juicklE anQ gktithe c2
>g ' å
>%S òfe $Nã´Ý@d

看起来合理多了，用一些已知的来纠正试一下：

```python
know(0,1,'o')
know(0,4,'y')
know(0,10,'e')
know(0,14,'o')
know(1,25,'e')
know(0,17,'s')
know(0,19,' ')
```

获取明文：

>Now you need to use the kn
>own flag as the key of One
> Time Pad Encryptin. Now t
>hat you have passed the pr
>evious RSA test, this chal
>lenge is not particularly}
>please get the true messag
>difficult for you. It is j
>ust simple encryption.I ho
>pe you can solve this prob
>lem quickly and get the co
>g-';å
>%Sòfe$Nã_´Ý@d}

最后两行异常，猜测应该是用于生成flag

最终解密

```python
key = xo.strxor(c[0], ''.join([chr(c) for c in msg[0]]).encode())
print(key)
```

得到答案：flag{it_1s_P@dd1n_@nd_p@d}

综合代码：

```python
import Crypto.Util.strxor as xo
import libnum, codecs, numpy as np

def isChr(x):
    if ord('a') <= x and x <= ord('z'): return True
    if ord('A') <= x and x <= ord('Z'): return True
    return False

def infer(index, pos):
    if msg[index, pos] != 0:
        return
    msg[index, pos] = ord(' ')
    for x in range(len(c)):
        if x != index:
            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(' ')

dat = []

def getSpace():
    for index, x in enumerate(c):
        res = [xo.strxor(x, y) for y in c if x!=y]
        f = lambda pos: len(list(filter(isChr, [s[pos] for s in res])))
        cnt = [f(pos) for pos in range(len(x))]
        for pos in range(len(x)):
            dat.append((f(pos), index, pos))

c = [codecs.decode(x.strip().encode(), 'hex') for x in open(r"E:\Desktop\one_time_cipher", 'r').readlines()]

msg = np.zeros([len(c), len(c[0])], dtype=int)

getSpace()

dat = sorted(dat)[::-1]
for w, index, pos in dat:
    infer(index, pos)

print('\n'.join([''.join([chr(c) for c in x]) for x in msg]))

print()
print()


def know(index, pos, ch):
    msg[index, pos] = ord(ch)
    for x in range(len(c)):
        if x != index:
            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(ch)
know(0,1,'o')
know(0,4,'y')
know(0,10,'e')
know(0,14,'o')
know(1,25,'e')
know(0,17,'s')
know(0,19,' ')


print('\n'.join([''.join([chr(c) for c in x]) for x in msg]))



key = xo.strxor(c[0], ''.join([chr(c) for c in msg[0]]).encode())
print(key)
#b'flag{it_1s_P@dd1n_@nd_p@d}'
```

##### 原理解释

加密方式：用多个明文$M_i$异或等长密钥$key$得到对应密文$C_i$，如果明文过多，则攻击者容易推测出$key$进而解释明文$M_i$，于是在已知明文为英文句子的前提下，可以利用异或的交换律结合律以及自身作逆元的性质进行猜测破解
$$
C_i \oplus C_j = (M_i \oplus key) \oplus (M_j \oplus key)=M_i \oplus M_j
$$
如果我们尝试用$C_1$分别去异或其他密文，也就等价于$M_1$去异或其他明文，会得到什么：

```python
from Crypto.Util.number import *
c = [0x280316470206017f5f163a3460100b111b2c254e103715600f13,0x091b0f471d05153811122c70340c0111053a394e0b39500f0a18,0x4638080a1e49243e55531a3e23161d411a362e4044111f374409,0x0e0d15470206017f59122935601405421d3a244e10371560140f,0x031a08080e1a540d62327f242517101d4e2b2807177f13280511,0x0a090f001e491d2c111d3024601405431a36231b083e022c1d00,0x16000406080c543854077f24280144451c2a254e093a0333051a,0x02050701120a01334553393f32441d5e1b716027107f19334417,0x131f15470800192f5d167f352e0716481e2b29010a7139600c12,0x1609411e141c543c501d7f232f0812544e2b2807177f00320b1f,0x0a090c470a1c1d3c5a1f2670210a0011093a344e103715600712,0x0141e04040f49153142043a22601711520d3a331d08260000000]
for i in c:
    print(long_to_bytes(c[0]^i))
```



>!\x18\x19\x00\x1f\x03\x14GN\x04\x16DT\x1c\n\x00\x1e\x16\x1c\x00\x1b\x0eEo\x05\x0b'
>
>b'n;\x1eM\x1cO%A\nE \nC\x06\x16P\x01\x1a\x0b\x0eT&\nWK\x1a'
>
>b'&\x0e\x03\x00\x00\x00\x00\x00\x06\x04\x13\x01\x00\x04\x0eS\x06\x16\x01\x00\x00\x00\x00\x00\x1b\x1c'
>
>b'+\x19\x1eO\x0c\x1cUr=$E\x10E\x07\x1b\x0cU\x07\rI\x07H\x06H\n\x02'
>
>b'"\n\x19G\x1cO\x1cSN\x0b\n\x10\x00\x04\x0eR\x01\x1a\x06U\x18\t\x17L\x12\x13'
>
>b'>\x03\x12A\n\nUG\x0b\x11E\x10H\x11OT\x07\x06\x00\x00\x19\r\x16S\n\t'
>
>b'*\x06\x11F\10\x0c\x00L\x1aE\x03\x0bRT\x16O\x00]Ei\x00H\x0cSK\x04'
>
>b';\x1c\x03\x00\n\x06\x18P\x02\x00E\x01N\x17\x1dY\x05\x07\x0cO\x1aF,\x00\x03\x01'
>
>b'>\nWY\x16\x1aUC\x0f\x0bE\x17O\x18\x19EU\x07\rI\x07H\x15R\x04\x0c'
>
>b'"\n\x1a\x00\x08\x1a\x1cC\x05\t\x1cDA\x1a\x0b\x00\x12\x16\x11\x00\x00\x00\x00\x00\x08\x01'
>
>b')B\xf6\x07B\xf2\x90,K6y\x96F\x11z\x04;\xff\x86\x7f\xc0\xb5u`\x0f\x13'

看着很乱，我们改一下，把不可见字符全改为'.'来替换：

>!......GN..DT.........Eo..
>n;.M.O%A.E .C..P....T&.WK.
>&..............S..........
>+..O..Ur=$E.E...U..I.H.H..
>"..G.O.SN......R...U...L..
>\>..A..UG..E.H.OT.......S..
>\>*..F...L.E..RT.O.]Ei.H.SK.
>\>;......P..E.N..Y...O.F,...
>\>.WY..UC..E.O..EU..I.H.R..

Typora没有按字符对齐，上图片吧：

![MxorM](.\writeup.assets\MxorM.png)

发现有些列的英文字母较多，根据ASCII表：

- 0x00~0x1F 为控制字符
- 0x20 空格字符
- 0x30~0x39 数字字符
- 0x41~0x5A 大写英文字母
- 0x61~0x7A 小写英文字母

观察发现，
$$
\forall c \in [\mathrm{0x41},\mathrm{0x5A}],c \oplus \mathrm{0x20} = c+\mathrm{0x20} \in [\mathrm{0x61},\mathrm{0x7A}]
$$
很有趣的性质，这意味着如果某列英文字母有许多，作公共异或因子的可能为空格字符，于是根据这个性质，[Pion1eer](https://www.ruanx.net/)大佬写出了判断英文字符的脚本：

```python
def isChr(x):
    if ord('a') <= x and x <= ord('z'): return True
    if ord('A') <= x and x <= ord('Z'): return True
    return False
```

以及根据英文字符多少选取哪一行来与其他行异或再异或空格字符，得到不完全明文的脚本：

```python

def infer(index, pos):
    if msg[index, pos] != 0:
        return
    msg[index, pos] = ord(' ')
    for x in range(len(c)):
        if x != index:
            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(' ')

dat = []

def getSpace():
    for index, x in enumerate(c):
        res = [xo.strxor(x, y) for y in c if x!=y]
        f = lambda pos: len(list(filter(isChr, [s[pos] for s in res])))
        cnt = [f(pos) for pos in range(len(x))]
        for pos in range(len(x)):
            dat.append((f(pos), index, pos))

```

最后根据经验推断错误判定的字符：

```python
def know(index, pos, ch):
    msg[index, pos] = ord(ch)
    for x in range(len(c)):
        if x != index:
            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(ch)
```

根据上述原理，自己重写脚本如下：

```python
from Crypto.Util.number import *
c = [0x280316470206017f5f163a3460100b111b2c254e103715600f13,0x091b0f471d05153811122c70340c0111053a394e0b39500f0a18,0x4638080a1e49243e55531a3e23161d411a362e4044111f374409,0x0e0d15470206017f59122935601405421d3a244e10371560140f,0x031a08080e1a540d62327f242517101d4e2b2807177f13280511,0x0a090f001e491d2c111d3024601405431a36231b083e022c1d00,0x16000406080c543854077f24280144451c2a254e093a0333051a,0x02050701120a01334553393f32441d5e1b716027107f19334417,0x131f15470800192f5d167f352e0716481e2b29010a7139600c12,0x1609411e141c543c501d7f232f0812544e2b2807177f00320b1f,0x0a090c470a1c1d3c5a1f2670210a0011093a344e103715600712,0x0141e04040f49153142043a22601711520d3a331d08260000000]
length = c[0].bit_length()//8+1
key = [0 for _ in range(length)]
#判断是否为[a-zA-z]字符
def IsAZaz(char):
    if ((ord('A') <= char) and (char <= ord('Z'))):
        return 1
    if ((ord('a') <= char) and (char <= ord('z'))):
        return 1
    return 0
#获取第line行左数第col个字符（从0）
def getc(line,col):
    displace = (length-1-col)*8
    return (c[line]>>displace&0xff)
#修正函数
def correct(line,col,letter):
    key[col] = getc(line,col) ^ ord(letter) ^ 0x20

if __name__ == '__main__':
    #寻可能的空格，存于key中
    for p in range (length):
        score = [0 for _ in c]
        for i in range(len(c)):
            for j in range(len(c)):
                score[i] += IsAZaz(getc(i,p) ^ getc(j,p))
        m = 0
        for i in range(len(score)):
            m = i if score[i]>score[m] else m
        key[p] = getc(m,p)
    
    print(key)
    #输出猜测的明文：
    for i in range(len(c)):
        for p in range(len(key)):
            char = getc(i,p) ^ key[p] ^ 0x20
            print(chr(char),end = '')
        print()
    
    print()
    print()
    #修正
    correct(0,1,'o')
    correct(0,4,'y')
    correct(3,25,'r')
    correct(0,17,'s')
    correct(0,19,' ')
    #修正后明文
    for i in range(len(c)):
            for p in range(len(key)):
                char = getc(i,p) ^ key[p] ^ 0x20
                print(chr(char),end = '')
            print()
    print()
    #输出key
    for i in range(length):
        print(chr(key[i]^ 0x20),end='')

```

### 只有0-4？

##### 题目描述

> Alice上小学一年级啦，她想给邻座的Bob传小纸条，但是她数学只学到写数字4，这该怎么办呢……

##### 题目提示

> 0-4？其实就是五进制啦。

##### 题目附件

> e = 3
> n1 = 331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004
> c1 = 310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243
>
> n2 = 302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114
> c2 = 112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344
>
> n3 = 332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323
> c3 = 10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242

##### 四进制解密

```python
e = 3
n1_ = '331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004'
c1_ = '310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243'

n2_ = '302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114'
c2_ = '112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344'

n3_ = '332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323'
c3_ = '10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242'


n1 = 0
c1 = 0
n2 = 0
c2 = 0
n3 = 0
c3 = 0
for i in list(n1_):
    n1 = n1*5+int(i)
for i in list(c1_):
    c1 = c1*5+int(i)
for i in list(n2_):
    n2 = n2*5+int(i)
for i in list(c2_):
    c2 = c2*5+int(i)
for i in list(n3_):
    n3 = n3*5+int(i)
for i in list(c3_):
    c3 = c3*5+int(i)
```

##### 中国剩余定理

设：
$$
x = m^e
$$
令：
$$
\begin{cases}
c_1 = x \space mod \space n_1\\
c_2 = x \space mod \space n_2\\
\dots \space \dots \space \dots \space \dots \\
c_N = x \space mod \space n_N\\
\end{cases}
$$

$$
n = \prod_{j = 1}^{N}n_j\\
g_i = \frac{n}{n_i}\\
h_i \equiv \frac{1}{g_i^{-1}} \pmod{n_i}\\
$$

则：
$$
x \equiv \sum_{i=1}^{N}g_ih_i \pmod{n}
$$

##### 解题脚本

```python

from gmpy2 import iroot
e = 3
n1_ = '331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004'
c1_ = '310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243'

n2_ = '302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114'
c2_ = '112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344'

n3_ = '332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323'
c3_ = '10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242'


n1 = 0
c1 = 0
n2 = 0
c2 = 0
n3 = 0
c3 = 0
for i in list(n1_):
    n1 = n1*5+int(i)
for i in list(c1_):
    c1 = c1*5+int(i)
for i in list(n2_):
    n2 = n2*5+int(i)
for i in list(c2_):
    c2 = c2*5+int(i)
for i in list(n3_):
    n3 = n3*5+int(i)
for i in list(c3_):
    c3 = c3*5+int(i)


n = n1 * n2 * n3
m1_ = n // n1
m2_ = n // n2
m3_ = n // n3
m1 = pow ( m1_ , -1 , n1)
m2 = pow ( m2_ , -1 , n2)
m3 = pow ( m3_ , -1 , n3)
a1 = m1 * m1_
a2 = m2 * m2_
a3 = m3 * m3_
x = (c1 * a1 + c2 * a2 + c3 * a3) % n

print(long_to_bytes(iroot(x,3)[0]))
#b'noxCTF{D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!}'
```

得到答案：noxCTF{D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!}

### Little RSA

##### 题目描述

> [HECTF 2021]

##### 题目附件

```python
import random
import hashlib
import string
import sympy
import gmpy2
from Crypto.Util.number import *

se = random.randint(1,1000)
random.seed(se)

STR = list(string.ascii_letters+string.digits)
proof = ''.join([STR[random.randint(1, 62)-1] for _ in range(20)])
digest = hashlib.sha256(proof.encode()).hexdigest()

print(proof[4:])
print(digest)

e = sympy.nextprime(int(bytes(proof[:4],'utf-8').hex(),16))
p = sympy.nextprime(random.randint(pow(2,1023),pow(2,1024)))
q = sympy.nextprime(random.randint(pow(2,1023),pow(2,1024)))
flag = b'HECTF{XXXXXXXXXXXXXXX}'
m = bytes_to_long(flag)
n = p*q
c = pow(m,e,n)
print(c)
'''
NYAdQidL59lHklvI
1c92e2001540854eb03a06aa37b7bdc76b41a42d315c6dafb02bb339de9a3f25
12424425564383219080490551209643464847620938168930079127681706857658268732506553762185733232174616369346638607986790966147165572856020333466266950817761290120789562282899235194115801039977159247279287016533562522176851376987246778559325369725945217698449887185588509259585902043152698222880550864805704835462119046093822533459389519887750590547895454677651757127860660687183857783014508127001807318860919181678041597391665738436983340807978924856116264434249926664228272176813107767851582594893815624629540970573254201006817388643737600565142486019783712277126799182049309476758941334813964777650021632346392783087599
'''

```

##### 解题思路

里面涉及随机数的生成，故推测用随机数的种子及伪随机来入手，先爆破解种子，在正向解p,q,d,m

***解proof***

```python
import hashlib
import string

def crack():
    STR = list(string.ascii_letters+string.digits)
    for a in STR:	#懒得用笛卡尔积了，直接嵌套
        for b in STR:
            for c in STR:
                for d in STR:
                    proof = a+b+c+d+'NYAdQidL59lHklvI'
                    if hashlib.sha256(proof.encode()).hexdigest() == '1c92e2001540854eb03a06aa37b7bdc76b41a42d315c6dafb02bb339de9a3f25':
                        print(proof)
                        return 0
if __name__ == '__main__':
    crack()

#jq3hNYAdQidL59lHklvI
```

***解se***

```python
import random
import string

STR = list(string.ascii_letters+string.digits)
proof = 'jq3hNYAdQidL59lHklvI'
for se in range(1,1000):
    random.seed(se)
    if  ''.join([STR[random.randint(1, 62)-1] for _ in range(20)])== proof:
        break
print(se)
#571
```

***解flag***

```python
import random
import hashlib
import string
import sympy
import gmpy2
from Crypto.Util.number import *

se = 571
random.seed(se)

STR = list(string.ascii_letters+string.digits)
proof = ''.join([STR[random.randint(1, 62)-1] for _ in range(20)])
digest = hashlib.sha256(proof.encode()).hexdigest()

e = sympy.nextprime(int(bytes(proof[:4],'utf-8').hex(),16))
p = sympy.nextprime(random.randint(pow(2,1023),pow(2,1024)))
q = sympy.nextprime(random.randint(pow(2,1023),pow(2,1024)))
flag = b'HECTF{XXXXXXXXXXXXXXX}'
m = bytes_to_long(flag)
n = p*q
phi = (p-1)*(q-1)
d = pow(e,-1,phi)
c = pow(m,e,n)
c = 12424425564383219080490551209643464847620938168930079127681706857658268732506553762185733232174616369346638607986790966147165572856020333466266950817761290120789562282899235194115801039977159247279287016533562522176851376987246778559325369725945217698449887185588509259585902043152698222880550864805704835462119046093822533459389519887750590547895454677651757127860660687183857783014508127001807318860919181678041597391665738436983340807978924856116264434249926664228272176813107767851582594893815624629540970573254201006817388643737600565142486019783712277126799182049309476758941334813964777650021632346392783087599
m = pow(c,d,n)
print(long_to_bytes(m))
#b'HECTF{yujnbg4rdsw3xdfvrfgyrtgvcd}'
```

得到答案HECTF{yujnbg4rdsw3xdfvrfgyrtgvcd}

### RSA?

##### 题目描述

> [HECTF 2021]

##### 题目附件

 ```python
from Crypto.Util.number import *
import gmpy2
import math
from flag import flag,e1,e2
assert flag[:6]==b'HECTF{'
m=bytes_to_long(flag)
while(1):
    p1=getPrime(512)
    q1=gmpy2.next_prime(p1)
    if p1%4==3 and q1%4==3:
        break
n1=p1*q1
c1=pow(m,e1,n1)
print('c1=',c1)
print('n1=',n1)
p2=getPrime(512)
q2=getPrime(512)
n2=p2*q2
m2=e1*getPrime(340)
c2=pow(m2,e2,n2)
print('c2=',c2)
print('n2=',n2)
print('e2=',e2)

#c1= 47916081717706538925639104682570684180170502544820197539239827441426724468768104306254078605230687136184497929
#n1= 164133678169710886720989064489094710242148933867688762980230890673424334054283751851389412792855634009922402873730095480540590589967587744481839586009206921690415208556737311431588106941893527836076971942678255228990259381439694065742253470463684082142779114879828632048097049587164541575068678559785497341341
#c2= 63878844405215916614306503133484342687866237414982537489487243642156715327887644418701791728466044672606833177790745723348407141495434918350324367721472060206442057535810542180796122799773614557047720846326110736372382283280049448530028736552356917154044523343646598823659486063811304671208433254991406080968
#n2= 81943314005002234143294576769951701354140501422348161833411886396153974002840590020014331444356263770668675416273077939014396178809052011274358602695903955726427501943378842406211922876951617483948075311923120200295968581991729752554553727773176109055672586268192629406914315361730879469185143748796847985621
#e2= 3

 ```

##### 解题思路

注意到$e1$被$e2$加密，且$e2$较小，尝试用***低加密指数攻击***，脚本来自[风二西](https://www.bilibili.com/read/cv13394072/)：

```python
import gmpy2
import libnum

def de(c, e, n):
    k = 0
    while True:
        mm = c + n*k
        result, flag = gmpy2.iroot(mm, e)
        if True == flag:
            return result
        k += 1
n= 81943314005002234143294576769951701354140501422348161833411886396153974002840590020014331444356263770668675416273077939014396178809052011274358602695903955726427501943378842406211922876951617483948075311923120200295968581991729752554553727773176109055672586268192629406914315361730879469185143748796847985621
e= 3
c= 63878844405215916614306503133484342687866237414982537489487243642156715327887644418701791728466044672606833177790745723348407141495434918350324367721472060206442057535810542180796122799773614557047720846326110736372382283280049448530028736552356917154044523343646598823659486063811304671208433254991406080968

m=de(c,e,n)
print(m)
#3997474330692954004892367968364354963663898428651951374234371210083046726737590992626245650194376316882
```

即

```python
e1*getPrime(340) = #3997474330692954004892367968364354963663898428651951374234371210083046726737590992626245650194376316882
```

易得因子$2$，商进行质因数检测和长度检测，证明$e1 = 2$

最后一解，直接用sympy的nthroot_mod函数：

```python
print(long_to_bytes(nthroot_mod(c1,e1,n1)))
#b'HECTF{Ra6in_1s_g0od!!!}'
```

得到答案：HECTF{Ra6in_1s_g0od!!!}

##### P.S.

注意到$p_1$和$q_1$是相邻的素数，且$n_1 = p_1 * q_1$，这里也不够安全，因为有$p_1 < \sqrt{n_1} < q_1$，

***解p1,q1***

```python
import gmpy2
import sympy
n1 = 164133678169710886720989064489094710242148933867688762980230890673424334054283751851389412792855634009922402873730095480540590589967587744481839586009206921690415208556737311431588106941893527836076971942678255228990259381439694065742253470463684082142779114879828632048097049587164541575068678559785497341341
q1 = sympy.nextprime(gmpy2.iroot(n1,2)[0])
p1 = n1 // q1
print('p1 = '+str(p1))
print('q1 = '+str(q1))
#p1 = 12811466667392570112903020723113200908135795522924343912673155238307646898630978112977114315459571857717363854146878156826948894915692623941799726230598787
#q1 = 12811466667392570112903020723113200908135795522924343912673155238307646898630978112977114315459571857717363854146878156826948894915692623941799726230600543
#验证：(p1%4==3)and(q1%4==3) = True
```

### Break_RSA

##### 题目描述

> [HECTF 2021]

##### 题目附件

```python
import gmpy2
from Crypto.Util.number import *
from flag import flag

m=bytes_to_long(flag)
n = 25348605574630284342864323710011622959543974652863854537355760576386763162531478272446867731299572532294812374775121121761898206639041068156270466457595336452690367719842145233764550634280981441631262047763246059814963741143303914063537003244814908763379320576260885158458898112416692583017869283284022878603506583499699525249773663841642694427307104140944360804367072787670581252816486834658346431010523135392357008103555699542414687172408709153334263858639251735462278292703380745537045458408951791720967957274781161667526873251066303708008043058246747534357368350540174588670636827470901518225473676343782182718627
e = 65537

high_p = p>>462
c=pow(m,e,n)

print(high_p)
print(c)

#c = 2838585968727601235811102000208810377763570403442263788723014651093563843294336508586280687833863346617299165812054489406097873361940320732653656106836742334351707641172590772691775696065643337783752853707871271348294775407491819788305857447836923575366699374649494685209530440846553788854498950165868767060103944397665695513568787251626526985821169261973233666633938348865538364532419767347878581021598781082997830762785442482278387265054844200419966175619215512361010529309496176507520460375493466772893213031156341155066854128910227539653777680017545678773463877481232404008355330164324877400343396249494527269803
#high_p = 14719840533805965441436310401180369285271789871612468412671201109363519708733266615333097147637913934699335461421648585440665652199846830713164628016025539243988107497052

```

##### 解题思路

查找资料发现应为***p高位攻击***

网络上找到风二西大佬脚本如下：

[【CTF-RSA】sage脚本_p高位攻击](https://www.bilibili.com/read/cv13467579)

```python
#sage
#脚本1
#根据题目，注意 2^60  60需要修改相应的位数  a = (p >> 60) << 60
def phase3(high_p, n):
    R.<x> = PolynomialRing(Zmod(n), implementation='NTL')
    p = high_p + x
    x0 = p.small_roots(X = 2^60, beta = 0.1)[0]

    P = int(p(x0))
    Q = n // P
    print(P)
    print(Q)
    assert n == P*Q

n=0x558477ce1d081f831cfa159290ee4fd14888422c216a16ad86e2b2d4335e3cb18ed0120a955f970b17b229a8e7d0ae1b6f0c40213ad0e127eba99ae0d8a82397
p4=0x8fbcbb7d1e9f393ee21b537d6e0bd2cf8629e315f4e356c1e000000000000000
e=0xf7278179324b11fd83d08aa6f
c=0x36e1c09ccad45cd63a0f07e704d3811c39d70cdfdad999d2df90255a76c58cf6fe99ac1ab1d5d99a4ce1a2ebdbfbc49ce72df2a0b90766ff84ab0ef62068d46b

phase3(p4, n)

#脚本2
n = 22127806011633861727954101002390179580447625543207045612671617864341845851658260004006826435219665722338399712799144283442305160095371386129132285556214330279867129279885732638085139970894386809975772641941102438472230541606849251235636928502018782288977994793382547376630461074356449893196487276906629063423071245785206275636191377977712166746567658967286739276282635616277590864547265366547379387583014365390660407286148179073747800137068237371705680826025177248889969809158386539617738762070772471531610084135064141878988874470291949704156926711239213996266350299670204058121040684469621186909795304289942430452869
p4=0xd8bf1376aaae63b3c4d693ca7f3d8a76270b7310bb8bd4608a98c9fdd85fc1ccc7c246b364e2779034057f0ec7a101bad64269d9dcca69f9b5c3462b058b94db0987aa09426c5e7634b3e19f56872693206790c6feef0c9ae662d73f1b12c3cd
e = 0x10001
pbits = 1024
kbits = pbits - p4.nbits()
print(p4.nbits())
p4 = p4 << kbits
PR.<x> = PolynomialRing(Zmod(n))
f = x + p4
roots = f.small_roots(X=2^kbits, beta=0.4)
if roots:
    p = p4+int(roots[0])
    print ("n: ", n)
    print ("p: ", p)
    print ("q: ", n/p)
```

但是直接移用发现无法获得正确的结果，在**Scr1w飞书群**找到**999**大佬留下的wp:

> copperSmith 已知p高位攻击，需要已知576位，位数不够需爆破

```python
# sage代码
from sage.all import *
n = 25348605574630284342864323710011622959543974652863854537355760576386763162531478272446867731299572532294812374775121121761898206639041068156270466457595336452690367719842145233764550634280981441631262047763246059814963741143303914063537003244814908763379320576260885158458898112416692583017869283284022878603506583499699525249773663841642694427307104140944360804367072787670581252816486834658346431010523135392357008103555699542414687172408709153334263858639251735462278292703380745537045458408951791720967957274781161667526873251066303708008043058246747534357368350540174588670636827470901518225473676343782182718627
p4 =0x3e67e7cacd2584224fb2026b40afbcc4281bd59f72f7801239d95c61c48ded7649924f794592fce806e032f16c2f4a90466905fc30037317074a6424d8bf078e959a1ed2d8e5c000 
e = 0x10001
pbits = 1024
for i in range(0,4096):
    p4=0x3e67e7cacd2584224fb2026b40afbcc4281bd59f72f7801239d95c61c48ded7649924f794592fce806e032f16c2f4a90466905fc30037317074a6424d8bf078e959a1ed2d8e5c000
    p4=p4+int(hex(i),16)
    kbits = pbits - p4.nbits()
    p4 = p4 << kbits
    PR.<x> = PolynomialRing(Zmod(n))
    f = x + p4
    roots = f.small_roots(X=2^kbits, beta=0.4)
    if roots:
        p = p4+int(roots[0])
        print( "n: ", n)
        print("p: ", p)
        print ("q: ", n/p)
        break
        
#python
import binascii
 
import gmpy2
 
n=25348605574630284342864323710011622959543974652863854537355760576386763162531478272446867731299572532294812374775121121761898206639041068156270466457595336452690367719842145233764550634280981441631262047763246059814963741143303914063537003244814908763379320576260885158458898112416692583017869283284022878603506583499699525249773663841642694427307104140944360804367072787670581252816486834658346431010523135392357008103555699542414687172408709153334263858639251735462278292703380745537045458408951791720967957274781161667526873251066303708008043058246747534357368350540174588670636827470901518225473676343782182718627
p=175291598691144385734605942626497705255006578905546418886064642928196575357506613757160461077172952201370910329627576253214930141283488629680747804990127332334248365911757696295261048132072932168934877328660015818962009282880480610739271604571895262501196040178408326867931785129466638803502350952450435274493
q=144608217187255757134474625014340241580631182230267839208404615279473207580562853750292440645179115757670131210491226065722899351426169450244362537870482493536291739087974239167143094667786088151632549315535825254637027232289907362937918799359767154011270178153003922786876972109441874633642633626435006583839
c = 2838585968727601235811102000208810377763570403442263788723014651093563843294336508586280687833863346617299165812054489406097873361940320732653656106836742334351707641172590772691775696065643337783752853707871271348294775407491819788305857447836923575366699374649494685209530440846553788854498950165868767060103944397665695513568787251626526985821169261973233666633938348865538364532419767347878581021598781082997830762785442482278387265054844200419966175619215512361010529309496176507520460375493466772893213031156341155066854128910227539653777680017545678773463877481232404008355330164324877400343396249494527269803
e = 0x10001
n = p * q
phi = (p - 1) * (q - 1)
d = gmpy2.invert(e, phi)
m = pow(c, d, n)
print(binascii.unhexlify(hex(m)[2:].strip("L")))
#HECTF{perseverance_prevails}
```

原来必须要求576位，999用*for i in range(0,4096):*对不足的12位进行了爆破

##### 疑问

主要是针对` PR.<x> = PolynomialRing(Zmod(n)) ` ，`f = x + p4`， `roots = f.small_roots(X=2^kbits, beta=0.4)`这三句话

如果要解$f$的话，$x$难道不就等于$n-p_4$吗，可是要求的难道不是$p$的低位么……`p = p4+int(roots[0])`不就会得到$p = p_4 + root = p_4 + (n-p_4) = n$，这怎么会得到正确的p的QAQ

##### 猜测

作示例：

```python
p = 97
q = 101
n = p * q
kbits = 2
p_h = p >> kbits << kbits
PR.<x> = PolynomialRing(Zmod(n))
f = x + p_h
roots = f.small_roots(X = 2^kbits , beta = .4)
print(roots)
#[1]
```

猜测$x$属于$0$到$n$的整数环，则$f(x) \equiv x + p_{high} \pmod n$ ，若

### re_rsa

##### 题目描述 [HECTF 2021]

##### 题目附件




## 流密码

## 古典密码

### *easyCaesar

##### 题目描述

> 简单的凯撒密码噢

##### 题目文件

```python
#python
from random import randint
from secret import flag
assert flag.startswith("flag{")
table = "xuwb52lj0md1qr43vayphf8enogz769kcsit"

displacement = randint(2**4, 2**8)
cipher = ""
for i in flag:
    if i not in table:
        cipher += i
    else:
        cipher += table[(table.find(i)+displacement) % len(table)]
print(cipher)
# kvzx{cslszzcw-rfos-nol4-rrf3-f5zrs54ywfr5}

```

displacement为一个随机数，让flag明文在table上进行凯撒，table并不大，直接遍历displacement，判断解密后的开头为'flag{'即为原明文，解题脚本如下：

```python
#python
from random import randint
table = "xuwb52lj0md1qr43vayphf8enogz769kcsit"
cipher = "kvzx{cslszzcw-rfos-nol4-rrf3-f5zrs54ywfr5}"
for j in range(len(table)):
    flag = ""
    for i in cipher:
        if i not in table:
            flag += i
        else:
            flag += table[(table.find(i)-j) % len(table)]
    if flag.startswith("flag{"):
        print(flag)
#flag{8eceaa87-b13e-43c5-bb12-19abe95071b9}

```

### *某种电码

##### 题目描述

>  不是所有密文都叫莫尔斯(得到的单词md5后再来提交)

##### Hint

> [博多码（Baudot code）- 古老的 5bit 编码](https://zh.wikipedia.org/wiki/博多式电报机) 

##### 题目附件

> -.-../...--/.---./.----

##### Baudot code 

| [大端序](https://zh.wikipedia.org/wiki/大端序) | [小端序](https://zh.wikipedia.org/wiki/小端序) |  数字标点符号集  |      字母集      |
| :--------------------------------------------: | :--------------------------------------------: | :--------------: | :--------------: |
|                                                |                                                |                  |                  |
|                     00000                      |                     00000                      |       Null       |       Null       |
|                     00100                      |                     00100                      |      Space       |      Space       |
|                     10111                      |                     11101                      |        1         |        Q         |
|                     10011                      |                     11001                      |        2         |        W         |
|                     00001                      |                     10000                      |        3         |        E         |
|                     01010                      |                     01010                      |        4         |        R         |
|                     10000                      |                     00001                      |        5         |        T         |
|                     10101                      |                     10101                      |        6         |        Y         |
|                     00111                      |                     11100                      |        7         |        U         |
|                     00110                      |                     01100                      |        8         |        I         |
|                     11000                      |                     00011                      |        9         |        O         |
|                     10110                      |                     01101                      |        0         |        P         |
|                     00011                      |                     11000                      |        –         |        A         |
|                     00101                      |                     10100                      |       Bell       |        S         |
|                     01001                      |                     10010                      |        $         |        D         |
|                     01101                      |                     10110                      |        !         |        F         |
|                     11010                      |                     01011                      |        &         |        G         |
|                     10100                      |                     00101                      |        #         |        H         |
|                     01011                      |                     11010                      |        '         |        J         |
|                     01111                      |                     11110                      |        （        |        K         |
|                     10010                      |                     01001                      |        ）        |        L         |
|                     10001                      |                     10001                      |        "         |        Z         |
|                     11101                      |                     10111                      |        /         |        X         |
|                     01110                      |                     01110                      |        :         |        C         |
|                     11110                      |                     01111                      |        ;         |        V         |
|                     11001                      |                     10011                      |        ?         |        B         |
|                     01100                      |                     00110                      |        ,         |        N         |
|                     11100                      |                     00111                      |        .         |        M         |
|                     01000                      |                     00010                      | Carriage return  | Carriage return  |
|                     00010                      |                     01000                      |    Line feed     |    Line feed     |
|                     11011                      |                     11011                      |                  | Shift to figures |
|                     11111                      |                     11111                      | Shift to letters |                  |

根据表格得到关键词"HACK"，进行md5加密，得到0a8459aa738b0a4faa05b8ef091810f4，加上前缀得到flag{0a8459aa738b0a4faa05b8ef091810f4}

## 分组密码

## 数论

## 格密码

## ECC

## labs

### math_lab0

##### 题目描述

> 输入得到的数字。

##### 题目附件

>The Greatest Common Divisor (GCD), sometimes known as the highest common factor, is the largest number which divides two positive integers (a,b).
>
>For a = 12, b = 8 we can calculate the divisors of a: {1,2,3,4,6,12} and the divisors of b: {1,2,4,8}. Comparing these two, we see that gcd(a,b) = 4.
>
>Now imagine we take a = 11, b = 17. Both a and b are prime numbers. As a prime number has only itself and 1 as divisors, gcd(a,b) = 1.
>
>We say that for any two integers a,b, if gcd(a,b) = 1 then a and b are coprime integers.
>
>If a and b are prime, they are also coprime. If a is prime and b < a then a and b are coprime.
>
>Now calculate gcd(a,b) for a = 66528, b = 52920 and enter it below.
>
>In python3, you can do this with "from gmpy2 import gcd"

##### 解题

```python	
#python
from gmpy2 import gcd
a = 66528
b = 52920
print(gcd(a,b))
```

得到答案：$$1512$$

### math_lab1

##### 题目描述

> 输入得到的数字。

##### 题目附件

> Let a and b be positive integers.
>
> The extended Euclidean algorithm is an efficient way to find integers u,v such that
>
> a * u + b * v = gcd(a,b)
>
> Using the two primes p = 26513, q = 32321, find the integers u,v such that
>
> p * u + q * v = gcd(p,q)
>
> Enter whichever of u and v is the lower number as the flag.
>
> In python3, you can do this with "from gmpy2 import gcdext"

##### 扩展欧几里得算法

- 贝祖定理

> 即如果a、b是整数，那么一定存在整数x、y使得ax+by=gcd(a,b)。
>
> 如果ax+by=m有解，那么m一定是gcd(a,b)的若干倍。
>
> 有一个直接的应用就是 如果ax+by=1有解，那么gcd(a,b)=1

-  辗转相除法

```c
//C
int gcd(int a,int b){
    return b==0 ? a : gcd(b,a%b);
}
```

##### 解题脚本

```python
#python
from gmpy2 import gcdext
p = 26513
q = 32321
_,u,v = gcdext(p,q)
print(u if u<v else v)
```

得到答案：$$-8404$$

### math_lab2

##### 题目描述

> 输入得到的数字。

##### 题目附件

> Imagine you lean over and look at a cryptographer's notebook. You see some notes in the margin:
>
> 4 + 9 = 1
> 5 - 7 = 10
> 2 + 3 = 5
>
> At first you might think they've gone mad. Maybe this is why there are so many data leaks nowadays you'd think, but this is nothing more than modular arithmetic modulo 12 (albeit with some sloppy notation).
>
> You may not have been calling it modular arithmetic, but you've been doing these kinds of calculations since you learnt to tell the time (look again at those equations and think about adding hours).
>
> Formally, "calculating time" is described by the theory of congruences. We say that two integers are congruent modulo m if a ≡ b mod m.
>
> Another way of saying this, is that when we divide the integer a by m, the remainder is b. This tells you that if m divides a (this can be written as m | a) then a ≡ 0 mod m.
>
> Calculate the following integers:
>
> 11 ≡ x mod 6
> 8146798528947 ≡ y mod 17
>
> The solution is the smaller of the two integers.

##### 没什么可说的，直接上脚本

```python
#python
x = 11 % 6
y = 8146798528947  % 17
print(x if x<y else y)
```

得到答案：$$4$$

### math_lab3

##### 题目描述

> 输入得到的数字

##### 题目附件

> The integers modulo p define a field, denoted Fp.
>
> A finite field Fp is the set of integers {0,1,...,p-1}, and under both addition and multiplication there is an inverse element b for every element a in the set, such that a + b = 0 and a * b = 1.
>
> Note that the identity element for addition and multiplication is different! This is because the identity when acted with the operator should do nothing: a + 0 = a and a * 1 = a.
>
> Lets say we pick p = 17. Calculate 3^17 mod 17. Now do the same but with 5^17 mod 17.
>
> What would you expect to get for 7^16 mod 17? Try calculating that.
>
> This interesting fact is known as Fermat's little theorem. We'll be needing this (and its generalisations) when we look at RSA cryptography.
>
> Now take the prime p = 65537. Calculate 273246787654^65536 mod 65537.

##### 解题脚本(使用快速幂)

```python
#python
print(pow(273246787654,65536,65537))
```

得到答案

##### 解题思路(费马小定理)

如果a是一个整数，p是一个质数，且gcd(a,p)=1，那么a^p-a是p的倍数，也可以表示为：
$$
a^{p} \equiv a \space (mod \space p)
$$
或：
$$
a^{p-1} \equiv 1 \space (mod \space p)
$$
证明参见：[费马小定理-wiki](https://zh.wikipedia.org/zh-cn/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86)

### math_lab4

##### 题目描述

> 输入得到的数字。

##### 题目附件

>As we've seen, we can work within a finite field Fp, adding and multiplying elements, and always obtain another element of the field.
>
>For all elements g in the field, there exists a unique integer d such that g * d ≡ 1 mod p.
>
>This is the multiplicative inverse of g.
>
>Example: 7 * 8 = 56 ≡ 1 mod 11
>
>What is the inverse element: 3 * d ≡ 1 mod 13?
>
>In python3, you can do this with "from gmpy2 import invert"

##### 解题脚本

```python
#python
from gmpy2 import invert
print(invert(3,13))
#or we can do this with "pow(base,-1,mod)"
print(pow(3,-1,13))
```

得到答案：$$9$$

### math_lab5

##### 题目描述

> 输入得到的数字

##### 题目附件

> We've looked at multiplication and division in modular arithmetic, but what does it mean to take the square root modulo an integer?
>
> For the following discussion, let's work modulo p = 29. We can take the integer a = 11 and calculate a^2 = 5 mod 29.
>
> As a = 11, a^2 = 5, we say the square root of 5 is 11.
>
> This feels good, but now let's think about the square root of 18. From the above, we know we need to find some integer a such that a^2 = 18
>
> Your first idea might be to start with a = 1 and loop to a = p-1. In this discussion p isn't too large and we can quickly look.
>
> Have a go, try coding this and see what you find. If you've coded it right, you'll find that for all a ∈ Fp* you never find an a such that a^2 = 18.
>
> What we are seeing, is that for the elements of Fp*, not every element has a square root. In fact, what we find is that for roughly one half of the elements of Fp*, there is no square root.
>
> In other words, x is a quadratic residue when it is possible to take the square root of x modulo an integer p.
>
> In the below list there are two non-quadratic residues and one quadratic residue.
>
> Find the quadratic residue and then calculate its square root. Of the two possible roots, submit the smaller one as the flag.
>
> p = 29
> ints = [14, 6, 11]

##### 解题思路

形如$$x^{2} \equiv a\space(mod \space p)$$的方程成为**二次剩余方程**

在各数较小时，我们可以遍历正整数找到三个方程中最小的解

```python
#python
p = 29
ints = [14,6,11]
i = 0
while 1:
    if (i**2 % p) in ints:
        print(i)
        break
    i+=1
```

得到答案：$$8$$

### math_lab6

##### 题目描述

> 输入得到的数字。

##### 题目附件

> Legendre's Symbol: (a / p) ≡ a^((p-1)/2) mod p obeys:
>
> (a / p) = 1 if a is a quadratic residue and a ≢ 0 mod p
> (a / p) = -1 if a is a quadratic non-residue mod p
> (a / p) = 0 if a ≡ 0 mod p
>
> Which means given any integer a, calculating pow(a,(p-1)/2,p) is enough to determine if a is a quadratic residue.
>
> Now for the flag. Given the following 1024 bit prime and 10 integers, find the quadratic residue and then calculate its square root; the square root is your flag. Of the two possible roots, submit the larger one as your answer.
>
> So Legendre's symbol tells us which integer is a quadratic residue, but how do we find the square root?! The prime supplied obeys p = 3 mod 4, which allows us easily compute the square root. The answer is online, but you can figure it out yourself if you think about Fermat's little theorem.
>
> p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139
>
> ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565]

##### 解题思路

先用$$Legendre$$符号判定十个大整数是否为$$p$$的二次剩余

```python
#python
#p 和 ints的赋值语句在此处省略
def Legendre(n,p):
    result = pow(n,(p-1)//2,p)
    return -1 if (result==p-1) else result
for i in ints:
    print(Legendre(i,p),end=',')
#-1,-1,-1,-1,-1,1,-1,-1,-1,-1,
```

由此可知，有且仅有$$ints[5]$$是$$p$$的二次剩余，则求该二次剩余方程的解：

```python
#python
from sympy import nthroot_mod
print(max(nthroot_mod(ints[5],2,p,all_roots=True)))
```

得到答案：93291799125366706806545638475797430512104976066103610269938025709952247020061090804870186195285998727680200979853848718589126765742550855954805290253592144209552123062161458584575060939481368210688629862036958857604707468372384278049741369153506182660264876115428251983455344219194133033177700490981696141526

### math_lab7

##### 题目描述

> 输入得到的数字

##### 题目附件

> In Legendre Symbol we introduced a fast way to determine whether a number is a square root modulo a prime. We can go further: there are algorithms for efficiently calculating such roots. The best one in practice is called Tonelli-Shanks, which gets its funny name from the fact that it was first described by an Italian in the 19th century and rediscovered independently by Daniel Shanks in the 1970s.
>
> All primes that aren't 2 are of the form p ≡ 1 mod 4 or p ≡ 3 mod 4, since all odd numbers obey these congruences. As the previous challenge hinted, in the p ≡ 3 mod 4 case, a really simple formula for computing square roots can be derived directly from Fermat's little theorem. That leaves us still with the p ≡ 1 mod 4 case, so a more general algorithm is required.
>
> In a congruence of the form r^2 ≡ a mod p, Tonelli-Shanks calculates r.
>
> Tonelli-Shanks doesn't work for composite (non-prime) moduli. Finding square roots modulo composites is computationally equivalent to integer factorization.
>
> The main use-case for this algorithm is finding elliptic curve co-ordinates. Its operation is somewhat complex so we're not going to discuss the details, however, implementations are easy to find and Sage has one built-in.
>
> Find the square root of a modulo the 2048-bit prime p. Give the smaller of the two roots as your answer.
>
> a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768
> p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161

##### 解题步骤

同样使用sympy的nthroot_mod函数

```python
#python
from sympy import nthroot_mod
a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768
p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161
print(min(nthroot_mod(a,2,p,all_roots=True)))
```

得到答案：2362339307683048638327773298580489298932137505520500388338271052053734747862351779647314176817953359071871560041125289919247146074907151612762640868199621186559522068338032600991311882224016021222672243139362180461232646732465848840425458257930887856583379600967761738596782877851318489355679822813155123045705285112099448146426755110160002515592418850432103641815811071548456284263507805589445073657565381850521367969675699760755310784623577076440037747681760302434924932113640061738777601194622244192758024180853916244427254065441962557282572849162772740798989647948645207349737457445440405057156897508368531939120

### RSA_lab0

##### 题目描述

> 输入得到的数字

##### 题目附件

> All operations in RSA involve modular exponentiation.
>
> Modular exponentiation is an operation that is used extensively in cryptography and is normally written like: 2^10 mod 17
>
> You can think of this as raising some number to a certain power (2^10 = 1024), and then taking the remainder of the division by some other number (1024 mod 17 = 4). In Python there's a built-in operator for performing this operation: pow(base, exponent, modulus)
>
> In RSA, modular exponentiation, together with the problem of prime factorisation, helps us to build a "trapdoor function". This is a function that is easy to compute in one direction, but hard to do in reverse unless you have the right information. It allows us to encrypt a message, and only the person with the key can perform the inverse operation to decrypt it.
>
> Find the solution to 101^17 mod 22663

##### 解题

```python
#python
print(pow(101,17,22663))
```

得到答案：$$19906$$

### RSA_lab1

##### 题目描述

> 输入得到的数字

##### 题目附件

>RSA encryption is modular exponentiation of a message with an exponent e and a modulus N which is normally a product of two primes: N = p * q.
>
>Together the exponent and modulus form an RSA "public key" (N, e). The most common value for e is 0x10001 or 65537.
>
>"Encrypt" the number 12 using the exponent e = 65537 and the primes p = 17 and q = 23. What number do you get as the ciphertext?

##### 解题步骤

根据RSA的基本原理：

明文$$m$$，密文$$c$$

质数$$p,q$$，乘积$$n$$，欧拉数$$\phi$$，

公钥$$e$$，私钥$$d$$

有如下关系式：
$$
n = p \times q \\
\phi = (p-1) \times (q-1)\\
d \times e \equiv 1 \space (mod \space \phi)\\
c = m^{e} \space mod \space n\\
m = c^{d} \space mod \space n
$$
故编写解题脚本如下：

```python
#python
m = 12
p = 17
q = 23
e = 65537
n = p*q
c = pow(m,e,n)
print(c)
```

得到答案：$$301$$

### RSA_lab2

##### 题目描述

> 输入得到的数字。

##### 题目附件

> The private key d is used to decrypt ciphertexts created with the corresponding public key (it's also used to "sign" a message but we'll get to that later).
>
> The private key is the secret piece of information or "trapdoor" which allows us to quickly invert the encryption function. If RSA is implemented well, if you do not have the private key the fastest way to decrypt the ciphertext is to first factorise the modulus.
>
> In RSA the private key is the modular multiplicative inverse of the exponent e modulo the totient of N.
>
> Given the two primes:
>
> p = 857504083339712752489993810777
>
> q = 1029224947942998075080348647219
>
> and the exponent:
>
> e = 65537
>
> What is the private key d?

##### 解题思路

由上一题提到的RSA基本算法，可编写脚本如下：

```python
#python
p = 857504083339712752489993810777
q = 1029224947942998075080348647219
e = 65537
phi = (p-1) * (q-1)
d = pow(e,-1,phi)
print(d)
```

得到答案：$$121832886702415731577073962957377780195510499965398469843281$$

### RSA_lab3

##### 题目描述

> 输入得到的数字。

##### 题目附件

> I've encrypted a secret number for your eyes only using your public key parameters:
>
> N = 882564595536224140639625987659416029426239230804614613279163
>
> e = 65537
>
> Use the private key that you found for these parameters in the previous challenge to decrypt this ciphertext:
>
> c = 77578995801157823671636298847186723593814843845525223303932

##### 解题思路

注意到描述

> Use the private key that you found for these parameters in the previous challenge to decrypt this ciphertext:

发现本题的N恰好等于上一题(CRYPTO.labs.RSA_lab2)的p与q的乘积，故编写脚本如下：

```python
#python
p = 857504083339712752489993810777
q = 1029224947942998075080348647219
n = p*q
e = 65537
phi = (p-1) * (q-1)
d = pow(e,-1,phi)
c = 77578995801157823671636298847186723593814843845525223303932
m = pow(c,d,n)
print(m)
```

得到答案：13371337

### RSA_lab4

##### 题目描述

> 格式：crypto{}

##### 题目附件

```python
#!/usr/bin/env python3

from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes, GCD

e = 3

# n will be 8 * (100 + 100) = 1600 bits strong which is pretty good
while True:
    p = getPrime(100)
    q = getPrime(100)
    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)
    if d != -1 and GCD(e, phi) == 1:
        break

n = p * q

flag = b"XXXXXXXXXXXXXXXXXXXXXXX"
pt = bytes_to_long(flag)
ct = pow(pt, e, n)

print(f"n = {n}")
print(f"e = {e}")
print(f"ct = {ct}")

pt = pow(ct, d, n)
decrypted = long_to_bytes(pt)
assert decrypted == flag

# n = 742449129124467073921545687640895127535705902454369756401331
# e = 3
# ct = 39207274348578481322317340648475596807303160111338236677373

```

##### 解题思路

特别注意公钥$$e=3$$，非常小的公钥，故从这里进行**低加密指数分解攻击**

然而找了许多资料后，除了爆破并没有其他方法，爆破的脚本一般如下：

```python
#python 来源 风二西：https://www.bilibili.com/read/cv13394072/
import gmpy2
import libnum

def de(c, e, n):
    k = 0
    while True:
        mm = c + n*k
        result, flag = gmpy2.iroot(mm, e)
        if True == flag:
            return result
        k += 1
n= 14067473525623615859223663589118945198091192669401088734569589535726733244095067264729942915265175903139441309376381225701454902095234966599914234681888481774607095853830772571665038109641511499155604914228117882196188074964226780922239011682486198651997912713999544628177959592818928976240251790858062449396082494272361535640237914373270152455829541596341184902017633404494979208958080467979235974182507427501682492000572071306960595992848840147393057648929439822116261337091431441205378542080755128597543738922210525692259529009107645032171097155449558362749512243918901171631681472217935131865121871798425854707759
e= 3
c= 2217344750798294937344050117513831761010547351781457575945714176628679412650463329423466955026804439931765627111856888102133234836914006818023839994342283023142702993182665344445325734299047409223354338948863171846780674244925724334091153701697864918695050507247415283070309

m=de(c,e,n)
print(m)
print(libnum.n2s(int(m)).decode()) 
```

我将其多线程化：

```PYTHON
import gmpy2
from Crypto.Util.number import *
import multiprocessing
 
def func(i):
    print('start>>'+str(i))
    n = 742449129124467073921545687640895127535705902454369756401331
    e = 3
    c = 39207274348578481322317340648475596807303160111338236677373
    for k in range(i*10000000,(i+1)*10000000):
        mm = c + n*k
        result, flag = gmpy2.iroot(mm, e)
        if True == flag:
            while 1:
                print('finish>>'+str(result))

if __name__ == '__main__':
    p = multiprocessing.Pool()
    for i in range(1,100000000):
        p.apply_async(func , ([i]) )
    p.close()
    p.join()

```

但是仍然没有得到合适的结果，粗略估计也发现爆破方法不太合适，痛苦之余，尝试对n质因数分解：

[质因数分解](https://zh.numberempire.com/numberfactorizer.php)：

| **Factor**                     | **Power** | **Length** |
| ------------------------------ | --------- | ---------- |
| 752708788837165590355094155871 | 1         | 30         |
| 986369682585281993933185289261 | 1         | 30         |

还真⬛⬛能得到结果，于是写脚本如下：

```python
from Crypto.Util.number import *
p = 986369682585281993933185289261
q = 752708788837165590355094155871
phi = (p-1)*(q-1)
n = 742449129124467073921545687640895127535705902454369756401331
assert n == p*q
e = 3
d = pow(e,-1,phi)
c = 39207274348578481322317340648475596807303160111338236677373
m = pow(c,d,n)
print(long_to_bytes(m))
```

得到答案：crypto{N33d_b1g_pR1m35}

答案反混淆之后为"Need big primes"联想到题目附件的注释

> n will be 8 * (100 + 100) = 1600 bits strong which is pretty good

可知，本题确实是从n的分解入手(可恶，e取那么小，害我跑偏)

### RSA_lab5

##### 题目描述

> Why is everyone so obsessed with multiplying two primes for RSA. Why not just use one?

##### 题目附件

> n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591                                                                  
> e = 65537
> ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942  



##### 解题思路

应注意，n为1024bit的质数，推测与费马小定理相关：
$$
m^{n} \equiv m \space(mod \space n)
$$
根据RSA原理：
$$
c = m^{e} \space mod \space n\\
$$
需要寻找一个d使得：
$$
m=c^{d} \space mod \space n
$$
根据上面两式，求解d：
$$
m = c^{d} \space mod \space n\\
m = (m^{e} \space mod \space n)^{d} \space mod \space n\\
m = m ^{ed} \space mod \space n\\
ed \equiv 1 \space (mod \space (n-1))\\
d \equiv e^{-1} \space(mod \space (n-1))
$$
故编写解题脚本如下：

```PYTHON
#python
from Crypto.Util.number import long_to_bytes
n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591
e = 65537
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942
d = pow(e,-1,n-1)
m = pow(ct,d,n)
print(long_to_bytes(m))
```

得到答案：crypto{0n3_pr1m3_41n7_pr1m3_l0l}

### ECC_lab0

##### 题目描述

> 输入得到的坐标y值

##### 题目附件

> For all the challenges in the starter set, we will be working with the elliptic curve
> E: Y^2 = X^3 + 497 X + 1768, p: 9739
> Using the above curve, and the point P(8045,6936), find the point Q(x,y) such that P + Q = O.

正在学ECC喵

$O$为无穷远点，$O$对$y$轴的对称点依然为无穷远点，要使$PQ\bigcap E =O$，则应有$PQ$与$E$有且仅有$2$个交点，凭直觉$PQ$应该为垂直于$x$轴的直线，浅证一下吧：
$$
y^2 = x^3 + ax + b\\
2y \mathrm{d}y = 3x^2 \mathrm{d}x+a \mathrm{d}x\\
k = \frac{\mathrm{d}y}{\mathrm{d}x}=\frac{3x^2+a}{2y}\\
k^2 = \frac{9x^4+a^2+6ax^2}{4y^2}\\
k^2 = \frac{9x^4+a^2+6ax^2}{4x^3+4ax+4b}\\
\lim_{x \to \infty }{k^2} = \lim_{x \to \infty }{\frac{9x^4+a^2+6ax^2}{4x^3+4ax+4b}}=\infty
$$
可知该椭圆曲线向无穷远处发散，即只要$PQ$的斜率存在，则与椭圆曲线发散处有第三个交点

因此$Q(8045,-6936)$与$P$点关于$y$轴对称，提交答案，答案错误

仔细想想，想起来这是需要模$p$，计算$9739-6936=2803$，再次提交答案，答案正确

### ECC_lab1

##### 题目描述

> 输入得到的点的纵坐标。

##### 题目附件

> (a) If P = O, then P + Q = Q.
> (b) Otherwise, if Q = O, then P + Q = P.
> (c) Otherwise, write P = (x1, y1) and Q = (x2, y2).
> (d) If x1 = x2 and y1 = −y2, then P + Q = O.
> (e) Otherwise:
>   (e1) if P ≠ Q: λ = (y2 - y1) / (x2 - x1)
>   (e2) if P = Q: λ = (3x12 + a) / 2y1
> (f) x3 = λ2 − x1 − x2,     y3 = λ(x1 −x3) − y1
> (g) P + Q = (x3, y3)
>
> E: Y^2 = X^3 + 497 X + 1768, p: 9739
>
> You can test your algorithm by asserting: X + Y = (1024, 4440) and X + X = (7284, 2107) for X = (5274, 2841) and Y = (8669, 740).
>
> Using the above curve, and the points P = (493, 5564), Q = (1539, 4742), R = (4403,5202), find the point S(x,y) = P + P + Q + R by implementing the above algorithm.

$(a)$~$(g)$对椭圆曲线加密中的计算部分进行了简单概括，由于学习笔记里面已经写的很清，这里就不多分析了

第一句让我们进行测试，那就上脚本：

```python
import gmpy2
def sgn(x):
    if x > 0:
        return 1
    if x < 0:
        return -1
    if x == 0:
        return 0
class frac:
    def __init__(self,sign,numerator,denominator):
        self.sign = sign  
        self.numerator = numerator
        self.denominator = denominator
    def simplify(self):
        temp = frac(self.sign,self.numerator,self.denominator)
        if sgn(temp.denominator)*sgn(temp.numerator)==-1:
            temp.sign=-temp.sign
        temp.numerator = abs(temp.numerator)
        temp.denominator = abs(temp.denominator)
        gcd_value = gmpy2.gcd(temp.numerator, temp.denominator)
        return frac(temp.sign,temp.numerator // gcd_value , temp.denominator // gcd_value)
    def invert(self,p):
        return (self.sign*self.numerator * pow(self.denominator,-1,p)) % p
    def print(self):
        print(('+ 'if self.sign==1 else '- ')+str(self.numerator)+' / '+str(self.denominator))
class Point:
    def __init__(self,x,y):
        self.x = x
        self.y = y
    def __eq__(self,other):
        if self.x == other.x and self.y == other.y:
            return True
        else:
            return False
    def __add__(self,other):
        global E
        if self==other:
            k=frac(1, 3*(self.x**2)+E.a , 2*self.y)
        else:
            k = frac(1, other.y-self.y , other.x-self.x)
        k = k.simplify()
        k = k.invert(E.p)
        x3 = (k ** 2 - self.x - other.x) % E.p
        y3 = (k * (self.x - x3) - self.y) % E.p
        R = Point(x3,y3)
        return R
    def __mul__(self,n):  #只能写成右乘数了T_T
        T = Point(self.x,self.y)
        R = Point(self.x,self.y)
        n -= 1
        while n:
            if n & 1:
                R = R+T
            T = T+T
            n = n>>1
        return R
    def print(self):
        print((self.x,self.y))  
class Ellipse:
    def __init__(self,a,b,p):
        self.a=a
        self.b=b
        self.p=p

E = Ellipse(497,1768,9739)
X = Point(5274, 2841)
Y = Point(8669, 740)
(X+Y).print()
(X*2).print()
#(mpz(1024), mpz(4440))
#(mpz(7284), mpz(2107))
```

*（好容易才写出来的python脚本，可不得让我多用用，之后再转sage叭）*

解题脚本

```python
#python
E = Ellipse(497,1768,9739)
P = Point(493, 5564)
Q = Point(1539, 4742)
R = Point(4403,5202)
(P+P+Q+R).print()
#(mpz(4215), mpz(2162))
```

输入答案$2162$

### ECC_lab2

##### 题目描述

> 输入得到的点的纵坐标。

##### 题目附件

> E: Y^2 = X^3 + 497 X + 1768, p: 9739
>
> You can test your algorithm by asserting: 1337 X = (1089, 6931) for X = (5323, 5438).
>
> Using the above curve, and the points P = (2339, 2213), find the point Q(x,y) = 7863 P by implementing the above algorithm.

##### 解题脚本

```python
#python
E = Ellipse(497,1768,9739)
P = Point(2339, 2213)
(P*7863).print()
#(mpz(9467), mpz(2742))
```

输入答案$2742$

### Lattice_lab0

##### 题目描述

> 输入得到的数字

##### 题目附件

> Before defining a lattice or talking about how lattices appear in cryptography, let's review some of the basics of linear algebra. The following challenges should be considered as revision, if this is totally new to you, you might need to do a bit of background reading. As usual, we recommend "An Introduction to Mathematical Cryptography" by Hoffstein, Pipher, Silverman, as well as this excellent introduction to lattices and their applications.
>
> A vector space V over a field F is a set defined with two binary operators. For a vector v ∈ V, and a scalar a ∈ F, vector addition takes two vectors and produces another vector: v + w = z, for v,w,z ∈ V and scalar multiplication takes a vector and a scalar and produces a vector: a*v = w, for v,w ∈ V, a ∈ F.
>
>
> Let's consider a two dimensional vector space over the reals. A vector v ∈ V can be considered as a pair of numbers: v = (a,b) for a,b ∈ R. Vector addition works as v + w = (a,b) + (c,d) = (a+c, b+d), and scalar multiplication by c*v = c*(a,b) = (c*a, c*b).
>
> One can also define the inner product (also called the dot product), which takes two vectors and returns a scalar. Formally we think of this as v ∙ w = a for v,w ∈ V, a ∈ F. In our two-dimensional example, the inner product works as v ∙ w = (a,b) ∙ (c,d) = a*c + b*d.
>
> Time for the flag! Given a three dimensional vector space defined over the reals, where v = (2,6,3), w = (1,0,0) and u = (7,7,2), calculate 3*(2*v - w) ∙ 2*u.

##### 附件翻译（抽代术语好多，直接读真的吃力）

> 在定义格或讨论格在密码学中的应用之前，让我们回顾一些线性代数的基础知识。以下挑战应被视为复习，如果这对你来说是全新的，你可能需要进行一些背景阅读。像往常一样，我们推荐Hoffstein、Pipher、Silverman的《数学密码学导论》，以及这篇关于格及其应用的优秀介绍。
>
> 一个域 F 上的向量空间 V 是通过两个二元运算符定义的集合。对于向量 v ∈ V 和标量 a ∈ F，向量加法取两个向量并产生另一个向量：v + w = z，其中 v，w，z ∈ V，标量乘法取一个向量和一个标量并产生一个向量：a*v = w，其中 v，w ∈ V，a ∈ F。
>
> 让我们考虑一个二维实数向量空间。一个属于 V 的向量 v 可以看作是一对数字：v = (a,b)，其中 a，b ∈ R。向量加法的运算是 v + w = (a,b) + (c,d) = (a+c, b+d)，而标量乘法是 c*v = c*(a,b) = (c*a, c*b)。
>
> 还可以定义内积（也称为点积），它将两个向量映射为一个标量。在形式上，我们将其表示为 v ∙ w = a，其中 v，w ∈ V，a ∈ F。在我们的二维示例中，内积的计算方式是 v ∙ w = (a,b) ∙ (c,d) = a*c + b*d。
>
> 现在是解题时间！考虑一个定义在实数上的三维向量空间，其中 v = (2,6,3)，w = (1,0,0)，u = (7,7,2)，计算 3*(2*v - w) ∙ 2*u。

##### 解题

$$
\vec{v} = (2,6,3) \\
\vec{w} = (1,0,0) \\ 
\vec{u} = (7,7,2) \\
3(2\vec{v}-\vec{w})\cdot 2\vec{u}=3(2(2,6,3)-(1,0,0))\cdot 2(7,7,2)\\
=3(3,12,6)\cdot 2(7,7,2)\\
=(9,36,18)\cdot (14,14,4)\\
=12 \times 14 + 36 \times 14 + 18 \times 4 \\
=702
$$

### Lattice_lab1

##### 题目描述

> 输入得到的数字

##### 题目附件

> We say a set of vectors v1, v2, ..., vk ∈ V are linearly independent if the only solution to the equation:a1*v1 + a2*v2 + ... + ak*vk = 0 is for a1 = a2 = ... = ak = 0.
>
> A basis is a set of linearly independent vectors v1, v2, ..., vn ∈ V such that any vector w ∈ V can be written as: w = a1*v1 + a2*v2 + ... + ak*vn
>
> The number of elements in the basis is also the dimension of the vector space.
>
> We define the size of a vector, denoted ||v||, using the inner product of the vector with itself: ||v||2 = v ∙ v.
>
> A basis is orthogonal if for a vector basis v1, v2, ..., vn ∈ V, the inner product between any two different vectors is zero: vi ∙ vj = 0, i ≠ j.
>
> A basis is orthonormal if it is orthogonal and ||vi|| = 1, for all i.
>
> That's a lot of stuff, but we'll be needing it. Time for the flag. Given the vector v = (4, 6, 2, 5), calculate its size.

##### 题目附件翻译

>我们说向量集合 $v_1, v_2, ..., v_k \in V$ 是线性独立的，如果方程 $a_1v_1 + a_2v_2 + ... + a_kv_k = 0$ 的唯一解是 $a_1 = a_2 = ... = a_k = 0$.
>
>一个基是一组线性独立的向量 $v_1, v_2, ..., v_n \in V$，使得对于任意 $w \in V$，都可以写成：$w = a_1v_1 + a_2v_2 + ... + a_nv_n$.
>
>基的元素个数也是向量空间的维数。
>
>我们使用向量与自身的内积来定义向量的大小，表示为 $||v||$：$||v||^2 = v \cdot v$。
>
>如果一个向量基 $v_1, v_2, ..., v_n \in V$中，任意两个不同向量的内积为零，即 $v_i \cdot v_j = 0, i \neq j$，则该基是正交的。
>
>如果一个基是正交的，并且对于所有 $i$ 有 $||v_i|| = 1$，则该基是标准正交的。
>
>这是很多概念，但我们将需要它们。现在是解题时间。给定向量 $v = (4, 6, 2, 5)$，计算其大小。

##### 解题

$$
||\vec{v}|| = \sqrt{4^2+6^2+2^2+5^2}=\sqrt{81} = 9
$$

### Lattice_lab2

##### 题目描述

> 输入得到的数字

##### 题目附件

> In the last challenge we saw that there is a special kind of basis called an orthogonal basis. Given a basis v1, v2, ..., vn ∈ V for a vector space, the Gram-Schmidt algorithm calculates an orthogonal basis u1, u2, ..., un ∈ V.
>
> In "An Introduction to Mathematical Cryptography", Jeffrey Hoffstein, Jill Pipher, Joseph H. Silverman, the Gram-Schmidt algorithm is given as:
>
> Algorithm for Gram-Schmidt
>
> u1 = v1
> Loop i = 2,3...,n
>    Compute μij = vi ∙ uj / ||uj||2, 1 ≤ j < i.
>    Set ui = vi - μij * uj (Sum over j for 1 ≤ j < i)
> End Loop
>
>
> To test your code, let's grab the flag. Given the following basis vectors:
>
> v1 = (4,1,3,-1), v2 = (2,1,-3,4), v3 = (1,0,-2,7), v4 = (6, 2, 9, -5),
>
> use the Gram-Schmidt algorithm to calculate an orthogonal basis. The flag is the float value of the second component of u4 to 5 significant figures.

##### 题目附件翻译

> 在上一个挑战中，我们看到存在一种特殊类型的基底，被称为正交基底。对于向量空间 $V$ 中的基底$v_1, v_2, \cdots , v_n \in V$，Gram-Schmidt 算法计算出一个正交基底 $u_1, u_2, \cdots, u_n \in V$。
>
> 在《数学密码学导论》一书中，Jeffrey Hoffstein、Jill Pipher、Joseph H. Silverman 给出了 Gram-Schmidt 算法：
>
> Gram-Schmidt 算法
>
> $u_1 = v_1$ 循环 $i = 2,3,\cdots,n$ 计算 $μ_{i,j} = \frac{v_i \cdot u_j} { ||u_j||^2}$，其中 $1 ≤ j < i$。 设置 $u_i = v_i - μ\_{i,j} \cdot u_j$（对于 $1 ≤ j < i$ 求和） 循环结束
>
> 为了测试你的代码，让我们获取标志。给定以下基底向量：
>
> $v1 = (4,1,3,-1)，v2 = (2,1,-3,4)，v3 = (1,0,-2,7)，v4 = (6, 2, 9, -5)$。
>
> 使用 Gram-Schmidt 算法计算一个正交基底。`flag`是 $u_4$ 的第二个分量的浮点值，保留 $5$ 位有效数字。

### Lattice_lab3

##### 题目描述

> 输入得到的数字

##### 题目附件

> We can calculate the volume of the fundamental domain from the basis vectors. As an example, let us take a two dimensional lattice with basis vectors v = (2,5), u = (3,1). Create a matrix A with rows corresponding to the basis vectors: A = [[2,5],[3,1]]. The volume of the fundamental domain is the magnitude of the determinant of A: Vol(F) = |det(A)| = |2*1 - 5*3| = |-13| = 13.
>
> For the flag, calculate the volume of the fundamental domain with the basis vectors v1 = (6, 2, -3), v2 = (5, 1, 4), v3 = (2, 7, 1).

##### 题目附件翻译

> 我们可以通过基向量来计算基本区域的体积。举个例子，让我们考虑一个具有基向量 $v = (2,5)$ 和 $u = (3,1)$ 的二维格。创建一个矩阵 $A$，其行对应于基向量：$A = \begin{bmatrix} 2 & 5 \\ 3 & 1 \end{bmatrix}$基本区域的体积是矩阵 $A$ 的行列式的大小：$Vol(F) = |\text{det}(A)| = |2 \cdot 1 - 5 \cdot 3| = |-13| = 13$。
>
> 现在是解题时间。给定基向量 $v_1 = (6, 2, -3)$，$v_2 = (5, 1, 4)$，$v_3 = (2, 7, 1)$，计算基本区域的体积。

##### 解题

```python
#sage
A=matrix([[6,2,-3],[5,1,4],[2,7,1]])
print(abs(det(A)))
```

### Lattice_lab4

##### 题目描述

>  输入得到的数字

##### 题目附件

> If you look closely enough, lattices start appearing everywhere in cryptography. Sometimes they appear through manipulation of a cryptosystem, breaking parameters which were not generated securely enough. The most famous example of this is Coppersmith's attack against RSA cryptography.
>
> Lattices can also be used to build cryptographic protocols, whose security is based on two fundamental "hard" problems:
>
> The Shortest Vector Problem (SVP): find the shortest non-zero vector in a lattice L. In other words, find the non-zero vector within v ∈ L such that ||v|| is minimised.
>
> The Closest Vector Problem (CVP): Given a vector w ∈ R^m that is not in L, find the vector v ∈ L that is the closest to w, i.e. find the vector v ∈ L such that ||v - w|| is minimised.
>
> The SVP is hard for a generic lattice, but for simple enough cases there are efficient algorithms to compute either a solution or an approximation for the SVP. When the dimension of the lattice is four or less, we can compute this exactly in polynomial time; for higher dimensions, we have to settle for an approximation.
>
> Gauss developed his algorithm to find an optimal basis for a two-dimensional lattice given an arbitrary basis. Moreover, the output v1 of the algorithm is a shortest nonzero vector in L, and so solves the SVP.
>
> For higher dimensions, there's a basis lattice reduction algorithm called the LLL algorithm, named after Lenstra, Lenstra and Lovász. If you play CTFs regularly, you'll already know about it. The LLL algorithm runs in polynomial time. For now though, lets stay in two dimensions.
>
>
> Gauss's algorithm roughly works by subtracting multiples of one basis vector from the other until it's no longer possible to make them any smaller. As this works in two-dimensions, it's nice to visualise. Here's a description of the algorithm from "An Introduction to Mathematical Cryptography", Jeffrey Hoffstein, Jill Pipher, Joseph H. Silverman:
>
> Algorithm for Gaussian Lattice Reduction
>
> Loop
>    (a) If ||v2|| < ||v1||, swap v1, v2
>    (b) Compute m = ⌊ v1∙v2 / v1∙v1 ⌉
>    (c) If m = 0, return v1, v2
>    (d) v2 = v2 - m*v1
> Continue Loop
>
>
> Note the similarity to Euclid's GCD algorithm with the "swap" and "reduction" steps, and that we have round the float, as on a lattice we may only use integer coefficients for our basis vectors.
>
> For the flag, take the two vectors v = (846835985, 9834798552), u = (87502093, 123094980) and by applying Gauss's algorithm, find the optimal basis. The flag is the inner product of the new basis vectors.

##### 题目附件翻译

> 如果你仔细观察，格在密码学中随处可见。有时，它们通过对加密系统的操纵而出现，破解那些生成不够安全的参数。其中最著名的例子是Coppersmith对RSA密码学的攻击。
>
> 格还可以用于构建基于两个基本的“难”问题的加密协议：
> 最短向量问题（SVP）：在格 $L$ 中找到最短的非零向量。换句话说，找到满足 $||v||$ 最小化的非零向量，其中 $v \in L$。
> 最近向量问题（CVP）：给定一个不在 $L$ 中的向量 $w \in \mathbb{R}^m$，找到最接近 \(w\) 的在 \(L\) 中的向量 \(v\)，即找到使 $||v - w||$ 最小化的向量 $v \in L$。
>
> SVP 对于一般的格来说是困难的，但对于足够简单的情况，存在有效的算法来计算 SVP 的解或近似解。当格的维数为四维或更小时，我们可以在多项式时间内精确计算；对于更高维度，我们必须满足于一个近似解。
>
> 高斯开发了他的算法，用于在给定任意基的情况下找到二维格的最优基。此外，算法的输出 $v_1$ 是 $L$ 中的最短非零向量，从而解决了SVP。
>
> 对于更高维度，有一种基于基格缩减的算法称为LLL算法，以Lenstra、Lenstra和Lovász的名字命名。如果你经常参加CTF比赛，你可能已经知道这个算法。LLL算法在多项式时间内运行。然而，让我们现在保持在二维中。
>
> 高斯的算法大致通过从另一个基向量中减去倍数，直到无法再减小它们为止。由于这在二维中起作用，很容易进行可视化。以下是来自《数学密码学导论》（Jeffrey Hoffstein，Jill Pipher，Joseph H. Silverman）的高斯格缩减算法的描述：
>
> 高斯格缩减算法
> 循环
>   (a) 如果 $||v2|| < ||v1||$，交换 $v1$，$v2$
>   (b) 计算 $m = \lfloor \frac{v1 \cdot v2}{ v1 \cdot v1 }\rfloor$
>   (c) 如果 $m = 0$，返回 $v1，v2$
>   (d) $v2 = v2 - m \cdot v1$
> 继续循环
> 请注意与欧几里得的最大公约数算法的“交换”和“缩减”步骤的相似性，以及我们对浮点数进行了四舍五入，因为在格上我们只能使用整数系数来表示我们的基向量。
>
> 现在是解题时间。给定两个向量 $v = (846835985, 9834798552)$和 $u = (87502093, 123094980)$，通过应用高斯格缩减算法，找到最优基。标志是新基向量的内积。

# MISC

# OSINT

# IOT

# CISCN

# DUTCTF 2023

# HOMEWORK

## CRYPTO

### 简单数论

##### 题目文件

```python
#python
from Crypto.Util.number import bytes_to_long

assert len(flag) <= 50
assert str(bytes_to_long(flag) << 10000).endswith('1473327817893791860679080635376845598464916175771199125558742418628097409377550464912703622357336416382120404612476355317875179245511879304348013049276070451780858374753615872')

```



该逻辑可以抽象为：
$$
(f \times M ) \space mod \space N  =  c
$$
应注意：
$$
gcd(M,N) = gcd(N,c) = gcd(c,M)
$$
将三者最大公约数记为k，即：
$$
k = gcd(M,N) = gcd(N,c) = gcd(c,M)
$$
则可解该一次剩余方程：
$$
(f \times M ) \space  mod \space N =  c\\
(f \times \frac{M}{k} )\space mod \space \frac{N}{k} =  \frac{c}{k}\\
(f \times \frac{M}{k} ) \equiv  \frac{c}{k} \space (mod \space \frac{N}{k})\\ 
f \equiv  \frac{c}{k} \times (\frac{M}{k})^{-1}\space (mod \space \frac{N}{k})\\
f =  (\frac{c}{k} \times (\frac{M}{k})^{-1})\space mod \space \frac{N}{k}\\
$$
故编写脚本：

```python
#python
from Crypto.Util.number import *
from gmpy2 import *
M=1<<10000
c=1473327817893791860679080635376845598464916175771199125558742418628097409377550464912703622357336416382120404612476355317875179245511879304348013049276070451780858374753615872
N=10**int(log10(c)+1)
k=gcd(M,N)
f=(c//k*invert(M//k,N//k))%(N//k)
print(long_to_bytes(f))

```

得到答案：$$flag{feb41d1d-1312-40dc-86dc-d52e1c8aec00}

# REAL

# SSSCTF 2022

# SSSCTF 2023

